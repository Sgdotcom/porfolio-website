<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Where Do I Go From Here - Simon Grey</title>
  <link rel="icon" type="image/x-icon" href="assets/home/Artboard 1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="css/wdigfh-standalone.css">
  <link rel="preload" href="assets/Timeline 1.webm" as="video">
  <link rel="preload" href="assets/home/Artboard 1.png" as="image">
  <meta http-equiv="Cache-Control" content="max-age=31536000, public">
  <meta http-equiv="Expires" content="Wed, 20 Feb 2026 12:00:00 GMT">
  <meta name="description"
    content="Simon Grey's Where Do I Go From Here - Creative inspiration, design thoughts, and behind-the-scenes process from a Stockholm-based visual communications student.">
  <meta name="keywords"
    content="Simon Grey, Where Do I Go From Here, creative inspiration, design process, Stockholm, visual communications, blog, creative thoughts">
  <script src="JS/main.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>

  <!-- Web App & SEO Files -->
  <link rel="manifest" href="manifest.json">
  <link rel="search" type="application/opensearchdescription+xml" title="Simon Grey Portfolio" href="opensearch.xml">
  <link rel="browserconfig" href="browserconfig.xml">
  <style>
    /* Force Greyscale Buttons */
    .save-btn,
    #add-text-box,
    #export-moodboard {
      background: #1a1a1a !important;
      color: white !important;
      border: 1px solid rgba(255, 255, 255, 0.2) !important;
      padding: 8px 16px !important;
      border-radius: 4px !important;
      font-weight: 600 !important;
      cursor: pointer !important;
      transition: all 0.2s ease !important;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
    }

    .save-btn:hover,
    #add-text-box:hover,
    #export-moodboard:hover {
      background: #333 !important;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
    }

    /* Caption visibility in Edit Mode */
    .edit-mode .caption {
      opacity: 1 !important;
      transform: translateY(0) !important;
      pointer-events: auto !important;
      background: rgba(0, 0, 0, 0.7) !important;
    }
  </style>

</head>

<body>

  <header class="top-bar">
    <div class="left">
      <a href="index.html" style="color: inherit; text-decoration: none;">← BACK TO PORTFOLIO</a>
    </div>
    <div class="right">
      <button id="dark-toggle" aria-label="Toggle dark mode">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"
          stroke-linecap="round" stroke-linejoin="round">
          <path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path>
          <line x1="12" y1="4" x2="12" y2="12"></line>
        </svg>
      </button>
    </div>
  </header>

  <main class="moodboard-container">
    <div class="moodboard-header">
      <h1>WHERE DO I GO FROM HERE?</h1>
      <p>This is The Dump. My creative inspiration, design thoughts, and behind-the-scenes process.</p>
    </div>



    <div class="moodboard-grid" id="moodboard-grid" data-sort-key="moodboard-gallery">
      <!-- Placeholder squares -->
      <div class="moodboard-post text-placeholder" data-id="avail-soon">
        <span class="placeholder-body" data-default-text="Available soon">Available soon</span>
      </div>
      <div class="moodboard-post text-placeholder" data-id="load-art">
        <span class="placeholder-body" data-default-text="Loading art">Loading art</span>
      </div>

      <!-- Image posts will be injected here from assets/pictures-of/gallery.json -->

      <div class="moodboard-post text-placeholder" data-id="more-coming">
        <span class="placeholder-body" data-default-text="More coming">More coming</span>
      </div>
      <div class="moodboard-post text-placeholder" data-id="stay-tuned">
        <span class="placeholder-body" data-default-text="Stay tuned">Stay tuned</span>
      </div>
    </div>
  </main>

  <footer class="site-bottom" aria-label="Site footer">
    <p class="copyright">© 2026 Simon Grey. All rights reserved.
      <a href="?edit=1" class="edit-link-footer" id="edit-mode-trigger"
        style="color:inherit; text-decoration:none; margin-left:10px; opacity:0.5; display: inline-block;">Edit</a>
      <span class="edit-controls-footer" style="display: none;">
        <button id="add-text-box" type="button" class="save-btn">Add text box</button>
        <button id="export-moodboard" type="button" class="save-btn" style="margin-left:10px;">Export Changes</button>
        <a href="wdigfh.html" class="exit-edit-link"
          style="color:inherit; text-decoration:none; margin-left:10px; opacity:0.5;">Exit Edit Mode</a>
      </span>
    </p>
    <p class="wip-repeat" data-phrase="where do i go from here?">where do i go from here?</p>
  </footer>

  <script>
    const grid = document.getElementById('moodboard-grid');
    const editControlsFooter = document.querySelector('.edit-controls-footer');
    const editLinkFooter = document.querySelector('.edit-link-footer');
    let editMode = false;





    function setEditMode(active) {
      editMode = Boolean(active);
      if (!grid) return;

      grid.classList.add('edit-freeform');
      grid.classList.toggle('edit-mode', editMode);

      if (editControlsFooter) {
        editControlsFooter.style.display = active ? 'inline-block' : 'none';
      }
      if (editLinkFooter) {
        editLinkFooter.style.display = active ? 'none' : 'inline-block';
      }

      updateEditableTextBlocks(editMode);

      const headerP = document.querySelector('.moodboard-header p');
      if (headerP) {
        headerP.contentEditable = active;
        if (active) {
          headerP.addEventListener('input', () => saveLayout());
        }
        const savedHeader = localStorage.getItem('moodboard-header-p');
        if (savedHeader) headerP.textContent = savedHeader;
      }

      if (active) {
        initInteract();
      } else {
        if (typeof interact !== 'undefined') {
          interact('.moodboard-post').unset();
        }
      }
    }



    function initInteract() {
      if (typeof interact === 'undefined') return;

      const getGridCols = () => {
        if (window.innerWidth <= 576) return 2;
        if (window.innerWidth <= 992) return 5;
        return 10;
      };
      const getGridUnit = () => grid.clientWidth / getGridCols();
      const startY = 10;

      interact('.moodboard-post')
        .draggable({
          ignoreFrom: '.caption, .text-only-content, .placeholder-body',
          inertia: true,
          modifiers: [
            interact.modifiers.restrictRect({
              restriction: 'parent',
              endOnly: false
            })
          ],
          autoScroll: true,
          listeners: {
            start(event) {
              event.target.classList.add('dragging');
              event.target.style.zIndex = '1000';
            },
            move(event) {
              const target = event.target;
              const x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
              const y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

              target.style.transform = `translate(${x}px, ${y}px)`;
              target.setAttribute('data-x', x);
              target.setAttribute('data-y', y);

              // Calculate target slot index using center of the element
              const unit = getGridUnit();
              const unitH = unit * (4 / 3);
              const centerX = x + (unit / 2);
              const centerY = y + (unitH / 2);
              const col = Math.floor(centerX / unit);
              const row = Math.floor((centerY - startY) / unitH);

              const gridCols = getGridCols();
              const children = Array.from(grid.querySelectorAll('.moodboard-post'));
              let newIdx = col + (row * gridCols);
              newIdx = Math.max(0, Math.min(children.length - 1, newIdx));

              const oldIdx = children.indexOf(target);

              if (newIdx !== oldIdx && col >= 0 && col < gridCols) {
                if (newIdx > oldIdx) {
                  grid.insertBefore(target, children[newIdx].nextSibling);
                } else {
                  grid.insertBefore(target, children[newIdx]);
                }
                applyLayout();
              }
            },
            end(event) {
              const target = event.target;
              target.classList.remove('dragging');
              target.style.zIndex = '';
              applyLayout();
              saveLayout();
            }
          }
        })
        .resizable({
          ignoreFrom: '.caption, .text-only-content, .placeholder-body',
          edges: { right: true, bottom: true },
          margin: 15,
          listeners: {
            start(event) {
              event.target.classList.add('resizing');
            },
            move(event) {
              const target = event.target;
              const unit = getGridUnit();
              const unitH = unit * (4 / 3);

              const wUnits = Math.max(1, Math.round(event.rect.width / unit));
              const hUnits = Math.max(1, Math.round(event.rect.height / unitH));

              target.setAttribute('data-w-units', wUnits);
              target.setAttribute('data-h-units', hUnits);

              applyLayout();
            },
            end(event) {
              event.target.classList.remove('resizing');
              saveLayout();
            }
          }
        });
    }



    function updateGridHeight() {
      if (!grid) return;
      let maxBottom = 0;
      grid.querySelectorAll('.moodboard-post').forEach(post => {
        const y = parseFloat(post.getAttribute('data-y')) || 0;
        const h = post.offsetHeight || 0;
        if (y + h > maxBottom) maxBottom = y + h;
      });
      grid.style.minHeight = (maxBottom + 20) + 'px';
    }



    function saveLayout() {
      if (!grid) return;
      const posts = Array.from(grid.querySelectorAll('.moodboard-post'));
      const items = posts.map(post => {
        const media = post.querySelector('img, video');
        const textContent = post.querySelector('.text-only-content');
        const placeholder = post.querySelector('.placeholder-body');
        const caption = post.querySelector('.caption');

        let type = 'media';
        if (post.classList.contains('text-only')) type = 'text';
        if (post.classList.contains('text-placeholder')) type = 'placeholder';

        // Robust ID: prefer data-id, then media src, then text snippet
        const id = post.getAttribute('data-id') ||
          media?.getAttribute('data-src') ||
          media?.getAttribute('src') ||
          (post.textContent || '').trim().substring(0, 30);

        let content = null;
        if (textContent) content = textContent.textContent;
        else if (placeholder) content = placeholder.textContent;
        else if (caption) content = caption.textContent;

        return {
          id: id,
          type: type,
          content: content,
          wUnits: parseInt(post.getAttribute('data-w-units')) || 1,
          hUnits: parseInt(post.getAttribute('data-h-units')) || 1
        };
      });

      localStorage.setItem('moodboard-items-ordered-v2', JSON.stringify(items));
      console.log('Layout saved with', items.length, 'items');

      const headerP = document.querySelector('.moodboard-header p');
      if (headerP) {
        localStorage.setItem('moodboard-header-p', headerP.textContent);
      }
    }

    function applyLayout() {
      // Re-apply freeform logic based on current DOM order
      grid.classList.add('edit-freeform');
      const posts = Array.from(grid.querySelectorAll('.moodboard-post'));

      const getGridCols = () => {
        if (window.innerWidth <= 576) return 2;
        if (window.innerWidth <= 992) return 5;
        return 10;
      };

      const gridCols = getGridCols();
      const gridUnit = grid.clientWidth / gridCols;
      const unitH = gridUnit * (4 / 3);
      const startY = 10;

      // Keep track of filled cells in a virtual grid to avoid overlaps
      const gridState = []; // Array of rows, each row is an array of gridCols booleans

      function isAreaClear(r, c, w, h) {
        for (let i = r; i < r + h; i++) {
          for (let j = c; j < c + w; j++) {
            if (j >= gridCols) return false;
            if (gridState[i] && gridState[i][j]) return false;
          }
        }
        return true;
      }

      function markArea(r, c, w, h) {
        for (let i = r; i < r + h; i++) {
          if (!gridState[i]) gridState[i] = new Array(gridCols).fill(false);
          for (let j = c; j < c + w; j++) {
            gridState[i][j] = true;
          }
        }
      }

      posts.forEach((post) => {
        const wUnits = Math.min(gridCols, parseInt(post.getAttribute('data-w-units')) || 1);
        const hUnits = parseInt(post.getAttribute('data-h-units')) || 1;

        let found = false;
        let r = 0;
        let c = 0;

        while (!found) {
          if (isAreaClear(r, c, wUnits, hUnits)) {
            const x = c * gridUnit;
            const y = startY + (r * unitH);

            if (!post.classList.contains('dragging')) {
              post.style.transform = `translate(${x}px, ${y}px)`;
              post.setAttribute('data-x', x);
              post.setAttribute('data-y', y);
            }

            post.style.width = (wUnits * (100 / gridCols)) + '%';
            post.style.height = (hUnits * unitH) + 'px';

            markArea(r, c, wUnits, hUnits);
            found = true;
          } else {
            c++;
            if (c >= gridCols) {
              c = 0;
              r++;
            }
          }
        }
      });
      updateGridHeight();
    }

    function updateEditableTextBlocks(enabled) {
      if (!grid) return;
      grid.querySelectorAll('.placeholder-body').forEach(el => {
        el.contentEditable = enabled;
        if (!enabled && !el.textContent.trim()) {
          el.textContent = el.dataset.defaultText || el.textContent || 'Available soon';
        }
      });
      grid.querySelectorAll('.text-only-content, .caption').forEach(el => {
        el.contentEditable = enabled;
      });
    }

    function createTextBox(initial = 'Type something...', id = null) {
      const post = document.createElement('div');
      post.className = 'moodboard-post text-only user-text';
      if (!id) id = 'text-' + Date.now() + '-' + Math.random().toString(36).substr(2, 5);
      post.setAttribute('data-id', id);
      const body = document.createElement('div');
      body.className = 'text-only-content';
      body.textContent = initial;
      body.contentEditable = editMode;
      post.appendChild(body);
      return post;
    }

    function addTextBox() {
      if (!grid) return;
      const newBox = createTextBox();
      grid.appendChild(newBox);
      const editable = newBox.querySelector('.text-only-content');
      editable?.focus();
    }



    async function loadMoodboardGallery() {
      if (!grid) return;

      const manifestUrl = 'assets/pictures-of/gallery.json';

      try {
        const response = await fetch(manifestUrl, { cache: 'no-store' });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const payload = await response.json();
        const items = Array.isArray(payload?.items) ? payload.items : [];
        const anchor = grid.querySelector('.moodboard-post.text-only, .moodboard-post.wide-text');

        grid.querySelectorAll('.moodboard-post.auto-generated').forEach(el => el.remove());

        items.forEach((item, idx) => {
          const path = typeof item.path === 'string' ? item.path.trim() : '';
          if (!path) return;

          const isVideo = item.type === 'video';
          const post = document.createElement('div');
          post.className = 'moodboard-post photo-only auto-generated lazy';
          post.setAttribute('data-id', path); // Assign data-id for media items

          const media = document.createElement(isVideo ? 'video' : 'img');
          media.dataset.src = path;
          media.classList.add('lazy');

          if (isVideo) {
            media.autoplay = true;
            media.muted = true;
            media.loop = true;
            media.playsInline = true;
            media.setAttribute('playsinline', '');
          }

          post.appendChild(media);

          if (item.caption) {
            const caption = document.createElement('div');
            caption.className = 'caption';
            caption.textContent = item.caption;
            post.appendChild(caption);
          }

          if (anchor) {
            grid.insertBefore(post, anchor);
          } else {
            grid.appendChild(post);
          }
        });

        window.activateLazyLoad?.(grid);

        // Apply saved order if it exists
        const saved = localStorage.getItem('moodboard-items-ordered-v2');
        if (saved) {
          const orderedItems = JSON.parse(saved);
          const currentPosts = Array.from(grid.querySelectorAll('.moodboard-post'));

          const fragment = document.createDocumentFragment();
          const matchedNodes = new Set();

          orderedItems.forEach(item => {
            let post = currentPosts.find(p => {
              if (matchedNodes.has(p)) return false;

              const media = p.querySelector('img, video');
              const isPlaceholder = p.classList.contains('text-placeholder');
              const isText = p.classList.contains('text-only');
              const pid = p.getAttribute('data-id');
              const pText = (p.textContent || '').trim().substring(0, 30);

              // Match by exact data-id OR legacy text ID
              if (item.type === 'placeholder' && isPlaceholder) {
                return pid === item.id || pText === item.id;
              }
              if (item.type === 'text' && isText) {
                return pid === item.id || pText === item.id;
              }
              if (item.type === 'media' && media) {
                if (pid === item.id) return true;
                const msrc = media.getAttribute('data-src') || media.getAttribute('src') || '';
                return msrc === item.id || msrc.includes(item.id) || item.id.includes(msrc);
              }
              return false;
            });

            if (!post && (item.type === 'text')) {
              post = createTextBox(item.content || '', item.id);
            }

            if (post) {
              if (item.wUnits) post.setAttribute('data-w-units', item.wUnits);
              if (item.hUnits) post.setAttribute('data-h-units', item.hUnits);

              // Restore text content if saved
              if (item.content !== null) {
                const target = post.querySelector('.text-only-content, .placeholder-body, .caption');
                if (target) target.textContent = item.content;
              }

              fragment.appendChild(post);
              matchedNodes.add(post);
            }
          });

          // Leftovers
          currentPosts.forEach(post => {
            if (!matchedNodes.has(post)) fragment.appendChild(post);
          });

          grid.innerHTML = '';
          grid.appendChild(fragment);
        }

        applyLayout();
      } catch (error) {
        console.warn('Failed to load moodboard gallery manifest', error);
        if (window.location.protocol === 'file:') {
          const errorMsg = document.createElement('div');
          errorMsg.style.cssText = 'grid-column: 1/-1; padding: 40px; text-align: center; color: var(--accent); background: rgba(0,0,0,0.05); border-radius: 8px; margin: 20px;';
          errorMsg.innerHTML = `
            <h3>Local Testing Note</h3>
            <p>To view the gallery images, this page needs to be served via a local web server (CORS requirement).</p>
            <p style="font-size: 0.9em; opacity: 0.8;">Run <strong>python -m http.server</strong> in your project folder and visit <strong>localhost:8000/wdigfh.html</strong></p>
          `;
          grid.appendChild(errorMsg);
        }
      }
    }

    const moodboardGalleryReady = loadMoodboardGallery().catch(err => {
      console.warn('Moodboard gallery initialization failed', err);
    });

    function hydrateMoodboardPosts() {
      document.querySelectorAll('.moodboard-post img').forEach(img => {
        const src = img.dataset.src || img.src;
        if (!src) return;
        img.src = src;
        img.onload = () => {
          img.classList.add('loaded');
          img.parentElement?.classList.add('loaded');
        };
      });

      document.querySelectorAll('.moodboard-post video').forEach(video => {
        const src = video.dataset.src || video.src;
        if (!src) return;
        video.src = src;
        video.load();
        video.parentElement?.classList.add('loaded');
      });

      document.querySelectorAll('.moodboard-post').forEach(post => {
        if (post.classList.contains('text-placeholder')) return;
        post.classList.add('lazy');
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      moodboardGalleryReady.finally(() => {
        hydrateMoodboardPosts();
        const params = new URLSearchParams(window.location.search);
        const isEditing = params.has('edit');
        setEditMode(isEditing);

        if (isEditing) {
          if (editControlsFooter) editControlsFooter.style.display = 'inline-block';
          if (editLinkFooter) editLinkFooter.style.display = 'none';
        }
      });

      const addTextButton = document.getElementById('add-text-box');
      if (addTextButton) {
        addTextButton.addEventListener('click', addTextBox);
      }

      const exportBtn = document.getElementById('export-moodboard');
      if (exportBtn) {
        exportBtn.addEventListener('click', () => {
          const posts = Array.from(grid.querySelectorAll('.moodboard-post'));
          const htmlSnippet = posts.map(post => {
            const media = post.querySelector('img, video');
            const x = Math.round(parseFloat(post.getAttribute('data-x')) || 0);
            const y = Math.round(parseFloat(post.getAttribute('data-y')) || 0);
            const w = post.style.width || 'auto';
            const h = post.style.height || 'auto';

            const wUnits = post.getAttribute('data-w-units') || 1;
            const hUnits = post.getAttribute('data-h-units') || 1;
            const id = post.getAttribute('data-id') || '';

            if (media) {
              const tag = media.tagName.toLowerCase();
              const src = media.dataset.src || media.src;
              const captionEl = post.querySelector('.caption');
              const captionHtml = captionEl ? `\n  <div class="caption">${captionEl.textContent}</div>` : '';
              return `<div class="moodboard-post photo-only" style="width: ${w}; height: ${h};" data-x="${x}" data-y="${y}" data-w-units="${wUnits}" data-h-units="${hUnits}" data-id="${id}">
  <${tag} src="${src}" class="loaded">${captionHtml}
</div>`;
            } else if (post.classList.contains('text-only')) {
              const text = post.querySelector('.text-only-content').textContent;
              return `<div class="moodboard-post text-only" style="width: ${w}; height: ${h};" data-x="${x}" data-y="${y}" data-w-units="${wUnits}" data-h-units="${hUnits}" data-id="${id}">
  <div class="text-only-content">${text}</div>
</div>`;
            } else if (post.classList.contains('text-placeholder')) {
              const text = post.querySelector('.placeholder-body').textContent;
              return `<div class="moodboard-post text-placeholder" style="width: ${w}; height: ${h};" data-x="${x}" data-y="${y}" data-w-units="${wUnits}" data-h-units="${hUnits}" data-id="${id}">
  <span class="placeholder-body">${text}</span>
</div>`;
            }
            return '';
          }).filter(Boolean).join('\n');

          const modal = document.createElement('div');
          Object.assign(modal.style, {
            position: 'fixed', top: '0', left: '0', width: '100%', height: '100%',
            background: 'rgba(0,0,0,0.8)', zIndex: 100001, display: 'flex',
            alignItems: 'center', justifyContent: 'center'
          });

          const textarea = document.createElement('textarea');
          textarea.value = htmlSnippet;
          Object.assign(textarea.style, {
            width: '80%', height: '80%', fontFamily: 'monospace', fontSize: '12px', padding: '10px'
          });

          const close = document.createElement('button');
          close.textContent = 'CLOSE';
          Object.assign(close.style, {
            position: 'absolute', top: '20px', right: '20px', padding: '10px',
            background: 'white', border: 'none', cursor: 'pointer'
          });
          close.onclick = () => modal.remove();

          modal.appendChild(textarea);
          modal.appendChild(close);
          document.body.appendChild(modal);
        });
      }

      // Add auto-save for text content
      grid.addEventListener('input', (e) => {
        if (e.target.classList.contains('text-only-content') ||
          e.target.classList.contains('placeholder-body') ||
          e.target.classList.contains('caption')) {
          saveLayout();
        }
      });
    });

    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          func(...args);
        }, wait);
      };
    }

    window.addEventListener('resize', debounce(() => {
      applyLayout();
    }, 100));


  </script>

</body>

</html>